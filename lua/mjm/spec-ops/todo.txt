------------
PROJECT WIDE
------------

- Reginfo:
    - The op (either "y", "d", or "p")
    - Return reg table, reg text, v type and letter type (with block lengths in each)
    - only return regtext on p
    - take in handler

- Need to address the case where the cursor is on the edge of the screen and then a cursor movement is applied to it. Delete/change/substitute/visual paste all apply here
- I think we make the ring behavior the default, right? But then we have to rename the "default" option
- Unsure what to do about automatic lazy loading. Hard to do at all because I'm not sure how we can do a plugin folder, and there's also the reality that, as is, most people use Lazy and lazy handles Lazy loading, so having the plugin do it risks a conflict
- Register bookkeeping
    - Maybe schedule_wrap register bookkeeping. But I'm not sure how that would affect mappings
- Add [y and ]y ring cycling
    - Big question - Do we support external storage beyond the registers? If so, this requires a picker and the means to deal with that. If not, then it's probably still better if there is the option to extend the plugin to add those other registers
    - Fundamentally unsure if the change marks should be modified or if a parallel mark system should be used
    - Optional highlight on cyclable area
    - Need to be able to handle reg-type changes as cycling happens. Do you always revert to the original paste?
    - Do x and X need to be handled internally to deal with this? I think they both write to the small delete register, so maybe not. But that doesn't necessarily account for visual mode. Though I think in visual mode you would just map them to the Delete plug map no?
- Handle zy, zp, gp. These create edge cases in how mark, spacing, and cursor handling need to be addressed
    - Note that zy trims trailing whitespace *within* the selection, not outside it
- https://github.com/neovim/neovim/issues/15136 -- Add this event
- The op state does not acutally need to be two separate tables
- Each operator needs to have an enabled flag that defaults to true
- Feel like, at this point, it's now or never for cpoptions y, because it would determine how yank operations are called. Like from an operatorfunc or a function or something else
- Double check that it's not possible to manually populate vim.v.event
- Make sure that the empty string issue doesn't happen on empty registers
- Do a major refactor of the functions and data handling, so we don't have edge case handling spread out. We should have the cases sufficiently defined that they can be routed where they need to go
    - Handle nil highlight timers
    - As a general note, look at what options are opts and which are not. Bad design choice that needs to be unwound
    - Make function lengths a page or less
    - Helper functions
        - Address block util PERF notes
        - Outline the binary search and fallback. In particular we want the fallback to run from the mid-point rather than re-iterating from the beginning
        - The parameter design of get-mtype is bad. Too many opts
        - Something awkward with the set utils is that we're assuming the marks were checked beforehand, which creates then like, each function doesn't have its own built-in assumptions. For this specific issue, again, just use the fallback that gbprod substitute does. But in general, Need to find a better balance between not checking every little thing at every point in the chain of responsibility, but also not making confusion about what edge cases are handled where
        - Because do_set takes in lines, we can't determine if the regtype is linewise or charwise on fallback. Was possible with text, but we need to calculate lines earlier. Unsure what gives here
        - Paste Utils
            - Too many layers deep in general
            - The block callback is the one outlier of integration. Either everything is integrated or none of it is
            - There are currently the setup paste lines function and the setup_text_lines function. These I think should be consolidated for consistent behavior
        - One problem with the block functions in general is you have the buf lines, the paste lines, and the op data as separate things that are passed around. I think the block op info holds the paste line, which is better, but the whole thing is still brittle and awkward, and I've had a lot of goofs in the coding because different things were transposed. But what makes it hard is that you need to be able to work with the buf line state before and after the paste. Maybe something you do is hold the vcol info along with the byte info (which would if nothing else solve a lot of the mark problems), so that way working with the after lines is more straight forward
            - In particular, keeping the block info would help with change marks where we are currently re-getting the vcol info in order to move the end block to be below the start block
        - The indent computation should return a function rather than re-calculating the indent method for each line
        - The indenting stuff should maybe an in op_utils
    - For substitute and paste, add a "smart cursor" option. That calculates dilated cursor position based on the original range/selection and the new range/selection
    - Make sure all types are annotated, including classes and M tables
    - The "on blank" condition is currently only applying to the first line. I think this might be incorrect
    - The behaviors for adjusting cursors should be modular and customizable. If you look at something like the pythagorean distance for visual operations, there's no reason a user shouldn't be able to apply that to their own operation
    - The current edge case handling for for char reg into block selection is particularly bad. Aside from creating duplicative API calls/mark table mods, it can also cause unexpected behavior with indenting
    - This includes TextYankPost events
    - Check for "no yank" conditions, such as user options or the black hole register, before yanking
        - And related to this, the error handling right now is confusing if yanking is disabled, whether through an option or through using the black hole register
    - More generally, don't include config options for yanking when simply going to the black hole suffices. For deletes, if you want black hole deletes, you can simply map that, or use the "should yank" handler to determine your use case. Whereas with substitute, because by default v:register is used to determine what register to substitute from, an option and plug map need to be available for determining whether to do a register swap
    - You can also say, for deletes and changes, if we're not yanking at all, then we don't need to check "should yank". Basically - think about what options mean what other options don't need to be used, particularly for yanking
        - For deletes and changes, yanking should not occur if the delete fails
    - Need to be more careful about what is a fatal error, what is a warning, and what is allowed to fail silently
        - Bad text objects: Use the fallback the substitute plugin uses
        - Now that the code is more mature, the various helper functions need to be smarter about edge case handling. Explicitly passing errors that could have been adjusted was fine when I was trying to work the code out, but the UX needs to take more focus now
    - The "should_reindent" function needs to be configurable globally and per function. It might even be good if it were possible to pass it in per keymap, so you can keymap certain types of indenting behavior
    - Something else to think about is - How things are config'd. This is talked about everywhere in here, but pertains to functions like should_reindent or should_yank. Or you also have stuff like the highlight groups. I think foregoing automatic keymaps is a good decision. Highlights are a bit more complicated because it should be possible to configure them globally or per operator. I think managing that manually could be a huge pain. On the other hand, rather than having a bit config function, it might be possible to have an individual function to pass a highlight group to emulate to the global namespace (or just have a command to edit the global namespace or highlight group), and then show how to setup the highlights for individual operators. The Neorocks doc I think poo-poohs setup functions a bit too much, and I think the vimscript experience of setting a bunch of individual g variables and keymaps is a bit annoying, and I think that setup functions help with lazy loading, but it's also bad to have a big bespoke setup table that requires a bunch of custom code around it to do things that are already built into Neovim
    - It should be possible for the plugin to handle its own lazy loading. Have a plugin file that's checked when it's sourced. If vim did_enter, then load it. If not, setup an autocmd to load it. It should be possible to make plug mappings early in your config. Then, the autocommand will trigger when you enter a buf. Then just make sure there's an option to load the plugin early if you want to for whatever reason
- Investigate yyy highlighting issue during omap. Does the default highlight yank behavior do this?
- It also seems like the highlight priority is lower than LSP diagnostic messages. Is this desirable? Should we document how to change?
- Look at the credits for yank and substitute, and ingest the docs from them and their alternatives
- https://github.com/nvim-neorocks/nvim-best-practices?tab=readme-ov-file -- Ingest this list
- https://github.com/inkarkat/vim-UnconditionalPaste - Ingest this
- Add multiply. Use this as a sandbox to figure out smart repeat and multi-count, so that way the method can just be ported over to substitute and yank. The repeat handler should be customizable
- Based on how multi-count works, store v:count as needed
- Implement multi-count for yank, substitute, and multiply
- TODO: Have a max lines to yank on delete option. Miniyank is 1000
- I think at this point we have to decide if we want case operations to a blocker to public release
    - If this is done, create a generalized helper function to iterate over characters by char_idx rather than byte. This should be something exposed as well
- The defaults should be the recommended option. I don't like when I download a plugin and I immediately have to goof with the defaults because they aren't the best user experience
- Create a test list and probably automated testing as well
    - TODO: https://github.com/neovim/neovim/issues/21460 - Verify that spec-ops performs the proper Vim behavior
- Structure on my computer for dev work
    - One pain point here is that vim.pack doesn't support local plugins yet
    - Ideally, I would have a dir synced to the current master version, a dev instance, and then could make other folders for pull requests
    - Also need to consider - Which version do I use? Prefer it be local

-------------
DOCUMENTATION
-------------

- What Neovim version(s) are required/supported
- The README should be relatively full featured. Shouldn't really be necessary to look at the VimDoc IMO
- No CoC
- Specific notes
    - How TextYankPost events are handled
    - The omode mappings in particular
    - buf_set_text triggers TextChanged. Should be documented in any API However, using setreg does not fire TextYankPost (as noted in the docs for that event), so it must be fired manually. Also document
    - How to create keymaps. Show Helix-style maps for customization examples
    - Recipes
        - Spongebob text
        - X delete
- This feels like an opportunity to revisit the cmp dict issue
- See what tools linkzaru uses for Markdown
- Vimdoc
    - In theory, the Vimdoc should integrate somehow with the main docs and the plugin. In particular, I would like to be able to write documentation local to the functions and have them be taken up by the Vimdoc like Neovim does, though I'm not sure if that's a build-step only thing, or if I need to implement some other process
- Public roadmap
- Contributing
    - Use the stylua.toml file
    - Please note non-goals

-----
PASTE
-----

- zp
    - Challenging for marks because the ragged edges can create cases where top right and bottom left marks are correct for representing the space. A lot of the internal functions currently assume, because we're currently only making rectangles, that the outputs will always be top left and top right
    - Repeats do not add white space padding to keep rectangles even across repeats, so lines keep their length ratio
    - Integrate in smart repeating though
- Alternative cursor options
    - Norm single line char after: Hold cursor
    - Norm single line char before: Either hold or beginning of pasted text
    - Norm multiline char after: Either hold or end of pasted text
    - Norm multiline char before: End of pasted text
    - Norm linewise: Hold cursor
    - Visual pastes: Pythagorean distance (also applies to substitutes and where to insert)
- By default, linewise reg into charwise selection visual past creates trailing whitespace on the original line being pasted into. An option should exist to remove this
- Right now, if you do a forced linewise paste, the regtype is set to "V" near the beginning of the paste callback. It could be interesting to do so after the count is applied to paste. So if you wanted to paste "foo" linewise, 3p would give you "foofoofoo" rather than "foo\nfoo\nfoo\n"
    - Counter argument though, if you have something charwise you want to paste repeatedly, then you want to be able to hit 2]p and make two new lines. It is probably best to keep the default behavior at linewise count, and if you want to do horizontal and vertical repetitions, reserve that for the multicount scenario

------
CHANGE
------

- The "insert_after" logic is basically a band-aid over bad mark design. Consider outlining or providing options for those functions
- Bug in block logic - for determining the insert point, only step back once. From what I can tell, we are only trying to go back far enough to get the two longest lines. Or it almost seems to be like, whatever the left boundary is, make sure we grab everything in it. We don't want to go back just to the shortest line, which is too much, just to make sure the boundaries can be represented

----------
SUBSTITUTE
----------

- Cursor options
    - before
    - after
    - pythagorean distance
- If the register to substitute from is empty, do you notify the user and quit or does it function like a delete? The default behavior IMO should be notify and exit so it doesn't do something unintended. Should it be a user option?

------
CONFIG
------

- Yank
    - Multi-count (y/n)
        - Smart repeat (y/n)
        - Change reg on dot repeat?

------
FUTURE
------

- Support preserveindent and copyindent for the indenting behavior

- Support virtualedit
- Properly factor in inclusive/exclusive operator behavior
- Maybe do the >p and <p pastes
    - One big argument against this is that we have the "should reindent" function already built in. It feels better to me if we show a recipe for creating >p and <p rather than make it built-in. On the other hand, it's part of unimpaired, which in and of itself is somewhat of a standard
    - A neat idea is to allow >p to accept a count so you can specify the indent. But that's an anti-pattern with <p then
- D removal
    - Similar to r" " in current visual mode, but automatically remove trailing whitespace
    - My kinda-sorta objection to this is - We are purposefully not using visual S out of respect for surround users. It feels patternful to say that visual Y, D, C, and P should be left open for user customization. So this might just end up being a personal mapping along with my X mapping. Or you could put it in a "recipes" section
        - For that X map, you could add a count to repeat the remainder after the rest is deleted. Use smart repeat

Example scenario:
- Three lines are yanked blockwise. The middle line is only whitespace
- Those lines are blockwise pasted
- The middle line being pasted over is shorter than the paste column
Neovim default behavior: The padding spaces to align with the paste column are added, but
the actual whitespace in the register is skipped over
This can be useful in case you want to do a block paste then gv and do a block insert
afterwards. An option should be added to skip the whitespce entirely though

-------------
DOCUMENTATION
-------------

- Make sure a default keymap config is provided

---------
NON-GOALS
---------

- Default keymap configuration
- Direct integration with external plugins, as this now creates an external target for the code base
    - Integration with external plugins should be in recipes or maybe documentation for specific cases
    - In general, the ability to integrate with an external plugin is an opportunity for extensibility, rather than something that should be built-in
    - Note, however, that we should take care to avoid interfering with the behavior of other plugins, particularly other plugins that border on being defaults

----------------
VISUAL CHECKLIST
----------------

**** if {sc, mc, sb} contains reg and contains motion **** {needs cursor}
sc > sc (char repeat) {set_text}
sc > mc (char repeat) {set_text}
sc > sb (char repeat) {set_text}
mc > sc (char repeat) {set_text}
mc > mc (char repeat) {set_text}
mc > sb (char repeat) {set_text}
sb > sc (char repeat) {set_text}
sb > mc (char repeat) {set_text}
sb > sb (char repeat) {set_text}

**** if motion == l **** {needs cursor}
sc > l (line repeat) {set_lines}
mc > l (line repeat) {set_lines}
sl > l (line repeat) {set_lines}
ml > l (line repeat) {set_lines}
sb > l (line repeat) {set_lines}
mb > l (line repeat) {set_lines}

**** if reg == l and {sc, mc} contains motion {needs cursor}
l > sc (line repeat, leading \n) {set_text}
l > mc (line repeat, leading \n) {set_text}

**** if {sb, mb} contains reg and contains motion -- {needs cursor}
sb > mb (block repeat) {set_block}
mb > sb (block repeat) {set_block}
mb > mb (block repeat) {set_block}

**** if reg == l and {sb, mb} contains motion -- {needs cursor}
l > sb (line repeat) {del_block, paste line before}
l > mb (line repeat) {del_block, paste line before}

**** if reg == sc and motion == mb -- {needs cursor}
sc > mb (char repeat, block transform) {set_block}

**** if reg == mb and motion == sc
mb > sc (block repeat) {set_block}

**** if reg == mc and motion == mb
mc > mb (char repeat) {set_block} -- sketchy because of \n in set_text

**** if reg == mb and motion == mc
mb > mc (block repeat) {set_text selection, block paste the rest} -- simple in theory

---------
OLD STUFF
---------

Global

- Look more at the code for mini.operators and Abolish's coerce function. Can learn about how certain problems are handled
- Replace any instances of math.huge with maxint
- Error messages should be printed at the site they occurred and pass up nil. Lua is not meant for passing up errors like a Rust or Go is. Make sure they are printed with vim.notify or nvim_echo so they go in the message history
- Unsure of what to do with the capitalized mappings. I'm kind of in a bind because Surround's default visual mapping is S, so I can't use that. I have to do P for behavior emulation, but Y, C, and D are kinda useless
- When everything is actually baked in, factor things properly so the right pieces are re-usable
- For delete and substitute, have a no yank whitespace option

Yank

- Make the yank function respect Neovim's option for setting change marks on yank
- Also make the yank function respect Neovim's cpoption for whether yanks are dot repeatable. One problem though is, how do you make it not overwrite the last dot repeat? Might not matter

Delete

- Add restore cursor option for block motions. Can tune behavior for other modes too

Paste

Substitute

- S eol should overwrite the first line of a linewise reg charwise. On the other hand, maybe the onus is on the user to put a v in the motion. I'm kind of okay with that because it removes voodoo from how the registers are managed relative to the defaults. On the other hand, that also makes the other lines not linewise, so they can't clear room like linewise pastes do

Other

- In general with change, it's the least important motion, but it's also lame if it's not there. The biggest issue is the visual block implementation. Maybe you just do a feedkeys on that part, maybe you just do a feedkeys on that but, but that's really lame
- Can the virtual block behavior be implemented. It doesn't create a lines nag so this is not a huge priority, but it feels like giving up at the 99 yard line

=====================
NICE TO HAVE/ANNOYING
=====================

Global

- Implement mini's double count trick? Globally? As an option?
- Test with virtualedit
- Use winsaveview for cursor restoration instead of simple cursor position
- Deal with dot repeat numbered reg implementation. Does this need to be re-implemented? Should it be? Should it be an option? Get reginfo has a is pointed to value, but I don't think you can set it.
- Different highlight groups for each function
- case editing functions
- In I think the normal.c file there's a big mentioned with the e or E motion. Does it mean anything?

Yank

- Count in visual mode yank should repeat the yank

Delete

- Make visual D emulate the D motion. So replace with spaces instead of outright deleting. For linemode, this is something I actually quite want (Maybe. You can count D and get rid of multiple lines that way. You could use this to like, create and leave space visually maybe)

- The default delete command doesn't take a count. Perhaps use that to multiple the amount of times it's yanked?

Paste

Substitute

========================
LOW PRIORITY/OVERLY HARD
========================

Global

- For emulating behavior, look around in the source code
- For substitute and paste (really though, applies to any visual mode too) - Calculate a smart cursor position. If your cursor is on -- position two in a four letter word, and you replace it with a six letter word, the cursor -- would end up on position three
- Trimming, padding, and formatting options
- It might be possible, by playing with virtual columns, to implement screenlinewise motions

Yank

- It would be useful to have block yank under delete pull the same info as the delete. The issue though is the block padding + low value

Delete

Paste

- Could be a neat option for visual paste to stay in visual mode after pasting would be interesting to implement zp/zP (zp would be easy, just put the padding behind an option)
- For cursor hold pastes, a thing can happen where if you do a linewise paste at the very bottom of the screen it will paste but you won't see it do anything. Solution: The view should move down to see it. The amount of down movement should be capped at scrolloff (check local as well) (Is there even a way to scroll through commands though?)

Substitute

- Substitute replace in place. So you could do sr and it would prompt you for what you want to replace the line with. Might be easier than a delete motion with only one use case

Other

- Add a repeat motion. It should be something like gmy to repeat a yank, gms to repeat a substitute. A thing to think about is, gmm intuitively feels like repeating the current line But it's touchy to have only gm let you into gmiw. What if a text object started with y or s? The more important design thing is that this should only work with unique counts, as supporting both behaviors adds comlpexity. Would still potentially create issues with gmm, but the problem is more narrowly scoped. Actually, because of the dot repeat problem, just don't do this If the user wants fine grained control over what to do, just use visual mode. The visual mode behavior would be the equivalent to ygv{count}p. The normal mode behavior would be something like v{count}{motion}y`>p. This doesn't feel that amazing without being able to do it with another operator, but see if the mini implementation does anything interesting with it

NEEDS RESEARCH

- https://github.com/svermeulen/vim-yoink - If doing a yank ring, this looks like the model. The [y/]y motions in particular are a nice touch. Also nvim-miniyank

---------
Mini-Yank
---------

- Being able to change the regtype of the pasted text is a cool idea. Maybe we can use [P and ]P for that. Actually [Y and ]Y works better because it doesn't take you out of the cycle for the current paste
- Lack of support for regtypes in unnamed and unnamed plus is mentioned. I think maybe, my stuff helps with yanking to them because I'm doing the bookkeeping manually, but for getting from, that gets tougher. I could look at miniyank's heurisitcs, but I'm not sure I even want to do that

------------
vim-easyclip
------------

The idea of an insert paste map is kind of interesting, but I'm not sure what it gives us that the default <C-R> doesn't already have

----------------------
vim-UnconditionalPaste
----------------------

- Forcing a flattened charwise paste is interesting
- In general, it would be good to have a filter for trailing and leading spaces. Smart repeat kinda handles this, but let's say you copy "  foo ", you should just be able to paste " foo ". But is that always desirable? Hard to say
- This is commentary, but, reading through the docs, there's like, a million different options for how spacing and linebreaks and flattening and such are handled. I get it. My config is too long. I think it's good to be able to define behaviors and I think the plugin should be able to support that, but when you have that many options, at some point it ceases to be a tool designed to solve problems and just becomes a toy. I think, as the options and extensions are designed, that sure yeah the user can do whatever they want and I think that capability should be supported as much as is feasible, but I am also trying to design something that allows me to solve problems, and I want users who are interested in solving problems. "Can you have five different default options for how to handle whitespace when pasting?" I would rather delete the plugin
- The separator function for block pasting might be useful if you're trying to do something like create tables in markdown. He calls it separator but I'm thinking delimiter. The author might be talking about something different than what I'm thinking
- He talks about pasting with delimited commas charwise. I'm guessing this is for CSV, but the implementation starts to get too goofy
- Another bit of commentary is - I get that there's value in plugins/motions that allow you to shortcut various things. Substitute is ultimately a shortcut for hitting the v key. Comment saves you some block mode editing. Surround saves you some going around word boundaries. But at some point there has to be a way to do things and having a million different options becomes a bit of a waste. Like even for block delimiting, can't you just gv and then I or A? Surround can also handle this case
- Something to keep in mind as well, the more the API can do, the more there is to maintain. You can't provide an API that makes certain functionality available then be like "well, you aren't supposed to use it that way." The API is a contract with the user and the contract must be honored
- All commentary aside, something I think could be useful is a function that allows you to specify delimiters. So you could do something like 3gp and you would be prompted for a delimiter like surround does, and then the repetitions would be separated by the delimiter. I can imagine this being useful if you're trying to do block transformations, and you rapidly want to take a block and duplicate it to the right with column separators, rather than having to move through and manually append separators to each one
- g=p and g=P are straightforward conceptually. This gets confused in visual mode though
- Would take the gUp and gUP mappings in a different direction - Apply the operator over the whole paste as that motion (so gUp makes the whole paste uppercase), and then add in different casing operators for stuff like title case
- I think the other "big idea" here is being able to replace within the paste contents. So if you have a multichar linewise paste you should be able to do something like gp\n, to replace newlines with commas. So now you're getting the power without having a million different mappings or options
- For whitespace management I think that should just be a function
- One conceptual/architectural thing is, I don't think we should be trying to have a grab bag of mix and match things you can do in the sense of, wooaahhhhhh it does this ending with this whitespace.
    - I think that the paste transformations should work in layers, and while you can control each layer, at some point the layers have to flow through in a certain way. So you can have stuff like, force a regtype, pre-count transformation, count options, post-count transformation, trim, whatever, and these can all be options you pass to the paste handler. They should apply themselves in a predictable way with pre-determined context. In addition to working in a way that is sane, if someone wants to make UnconditionalPaste, they can. If someone wants something simpler, they can also do that, and it's less defaults to worry about.
    - Maybe you even make [p and ]p recipe items rather than defaults. And from there I would keep defaults very minimal, if at all. Even smart repeat can, again, be a recipe item, or something specified in a recommended config. This applies to how cursor moves work as well. This makes maintenance easier too because instead of having to keep after a bunch of features, it's a matter of if context is reported correctly and/or adding new context, both of which are much simpler. And I think then you would move features to defaults based on adoption.
    - But something this all works against is keeping simple plug mappings as defaults
    - You can have like, config'd handlers and then the user can specify handlers either in the config or the mappings perhaps
    - A specific thing though I ran into - Taking a block selection and pasting it charwise with a delimiter

----------------------
LONG ESSAY ABOUT MARKS
----------------------

-- TODO: move this to op_state
-- - For chars, it looks like you can just do the del_chars one and use its marks
-- - But want to think more strategically before making any moves, because the insert_after
--   function in the current implementation is ghastly
-- - For lines, it looks, again, like you can just do a set
-- - The idea I think is that if you delete to the end of the line you want to go after, or else
--   you're going to be before the trailing whitespace
-- - I think the simpler way of doing this is you look and see if the mark is at the end of a line
-- - For char deletes, I think you just do marks.start.col both ways, and you check for max with
-- the line, then if you're at the end you go after. Seems simple ehough
-- For lines it's using a set, so we eliminate all the text what puts the cursor right at the
-- beginning, then the current logic (correctly) does S or cc to start properly indented
-- In both cases, I think we should start with individualized functions to control where
-- the marks are, but these should generalize out like they are now
-- For blocks, it gets weirder
-- In the change case, we can assume that we are always targeting a rectangle, which eliminates
-- some complication. We can also assume that we are using the delete method of picking cols to
-- remove. The start mark should be basically where it is on delete block, but, for specificity -
-- the start mark should end up on start row and start col. They can't "slide back" because they
-- already started on a beginning. I suppose a bad motion or manual mark edit could do that, but
-- I'm not interested in accomodating that. It would break the defaults too so, yeah
-- (though, if you wanted to be really safe, for each mark, at the beginning, you could check
-- the byte bounds and shift them to the starting bytes. Unlike finding a vcol, this doesn't
-- introduce a ton of time complexty, at least in the Lua)
-- But what I still don't have a good grasp on is how the marks handle ragged edges
-- Rather than the stepping through I'm doing right now, the simpler/more accurate way to do this
-- seems to be, you set the top mark like you would in a delete, then attempt to set the bottom
-- mark like you would in a delete. If the bottom mark can't go far enough to the right, then
-- you use that as the point to shift the top mark
-- This is a broader note for block boundaries that probably applies to zp as well, but you get
-- a top right mark when you have a block selection where it goes further out on a ragged edge
-- and that ragged edge is on top, but then you need the bottom mark to represent the block's
-- left boundary
-- This is more of a zp-point, but in terms of when curswant matters, say you have four lines.
-- Line one is the second longest, line four is the longest. If you $ to the end of line one and
-- select to line three, the topleft mark will show the left boundary, the bottom right mark
-- will be as far to the right as possible on line three, and then you'll need curswant to fill
-- in the remainder of the selection. If you gv this selection, you'll go to the botright mark and
-- be able to go to the end of line four by pressing j, because curswant wants to go there
-- Whereas if you start the block selection from the end of line one then create the same
-- selection, the topright mark will be at the end of line one and the botleft mark will be at
-- the start of the selection on line three. When you gv, you'll end up at the bottom mark
-- as before, but on the left, indicating that if you press j to go down to line four, the
-- selection will only extend as far to the right as the end of line one
-- When I start at a shorter line then introduce long ones, I don't see a different in the mark
-- pattern. Top left and bottom right, and curswant tells you if it fills out the hwole line or not
-- And then I notice that when actually doing the zp, the marks just go at the top left and then
-- the bottom right of the last line, both in normal and visual mode. tbf this removes a huge
-- coplication from the process so it's somewhat welcome
-- Something interesting to consider then is - if the right mark on a block selection = the
-- end of the line, do you need to check curswant? kinda. It can make a block selection that
-- gets the proper bounds without it, but then it relies on curswant to check behavior as you
-- grow the selection. My intuition is that it's probably better to just check it under the
-- necessary conditions, lest some edge case float by. Can be made a note to maybe, someday,
-- possibly check how the marks are made to see if their placements can be reverse deducted to see
-- if you need to check curswant
-- So then the move I think is to get the functions down without insert mode first, so we can
-- check how the marks go, then we can add the insert mode selections/checking
-- NOTE!: The end of line logic does not apply to zero lines, say you have these lines:
-- some line
-- another
-- If you delete starting from the n in another, the end mark would end up on a and you would
-- insert after. But if your block includes all of another, then you need to insert before
-- so you aren't inserting after a character in the first line
